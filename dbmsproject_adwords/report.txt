Basically, I divide this project into three steps: uploading data into Oracle database, matching advertisers to each query, and choosing the first K advertisers with higher quality score.

Uploading:
To upload data into Oracle database, I applied JDBC to achieve the goal. First, I used Java File I/O to read data from three .dat files, after that I made use of classes supplied by JDBC to create tables, and insert each line in the file into corresponding table. Note that inserting every tuple into table one by one is incredibly slow because there are thousands lines of data. In order to improve the effcience of execution, I used addBatch method supported by Statement and PreparedStatement class so that updates of same table are batched together and executed for one time. After batching, the uploading time is increased to about 10sec.

Matching:
For Matching I initially came up with a naive method, that for every query I scan the whole keywords table to check whether the keyword of one advertiser is member of the query. I abandoned this method. First of all it is terribly slow. The second is that there is chance of duplicating. That is, one advertiser might supply two keywords corresponding to the same query, and it would be chosen twice using this method. And the last, I have to write another function to compute the cosine similarity between keywords and queries in this way, which costs lots of computation.
To avoid unnecessary computation, I used pl/sql to achieve choosing. First I wrote a string split function in pl/sql, by which I divided queries into separate tokens, and stored tokens and their corresponding qid into a new table called qtoken.
Instead of creating a new function to compute the cosine similarity, I firstly computed the magnitude of each query using sql, by grouping every token in the same qid group, adding the square of counts of each token, and computing the square root of each sum. I created a new table named querymol to store the magnitude of each query and its qid.
Then in similar way I compute the magnitude of keyword supplied by each advertiser and stored the data in a new table named adkeymol.
The third step is natural joining table qtoken and table keywords group by qid and advertiserID to compute the frequence of apperance of each token in every query and total bid each advertiser should pay for its corresponding query. A third table is created named chosenkey to store the result. Last, a new table is created by natural joining querymol, adkeymol and chosenkey, named allinfo, where qid, advertiserID that bid for the query with that qid, the cosine similarity between keywords supplied by the advertiser and corresponding query and amount of bid is stored.
Now, I finished matching. Every advertiser has found its corresponding query by natural joining on the same keyword token. And the cosine similarity has been worked out. The next step is to execute the quality score and choose the first K ads.

Choosing:
In choosing the most concerning thing is the speed, or effcience of computation. With bad program structure it will take hours of time to finish one task with 10000 query.
My method is to iterate all the qid, and inside every iteration, use an implicit cursor pointing to the advertiser selected out to do the inserting and updating. Sorting is compeleted when selecting, so when first K updating has finished, stop inner iteration, run next qid, and start a new inner iteration.
Every chosen advertiser will and only will pay the bid when the module of its impression is less than ctc*100. I alter the advertisers table with column frequence and balance to record the time of impression of each advertiser and its remaining balance. If its balance is less than is bid for the query, it will not be selected out.
The last three tasks I use 'select .. case' to select the next highest bid. If the bid chosen is the smallest, then just select it out. Else select the largest bid among bids that are smaller than the chosen bid.

In this project I learned how to use JDBC to do sql query. And I also learned a lot about how to make a pl/sql program run faster. That is less iteration, less selection, less join, smaller table, and less variable. I learned to use 'with' instead of subquery to make sql query more efficient. I also found that many complex execution can be separated into simple computations which are easy to handle by sql.
On the other hand, in this first contact with pl/sql I learned how to create a function, how to create a procedure, how to invoke a function or a procedure, how to declare a new variable or a new type, and how to pass parameters and so on.
